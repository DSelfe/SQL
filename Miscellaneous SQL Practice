--Write a MySQL query to find all overlapping tasks, where one task starts before another ends but finishes after the second task has started. 

SELECT p1.Task_ID AS Task1, p2.Task_ID AS Task2
FROM Projects p1 
JOIN Projects p2 
ON p1.Task_ID < p2.Task_ID 
WHERE p1.Start_Date <= p2.End_Date 
AND p1.End_Date >= p2.Start_Date 
; 

--Write a MySQL query to create a summary showing the count of tasks that started in each month of 2024, displaying the month name and the corresponding count.

SELECT MONTHNAME(Start_Date) AS Month_Name, COUNT(Task_ID) AS Task_Count 
FROM Projects 
WHERE YEAR(Start_Date) = 2024 
GROUP BY MONTH(Start_Date), MONTHNAME(Start_Date)
ORDER BY MONTH(Start_Date)
; 

----Write a MySQL query to identify tasks with unusually long durations, specifically those that took more than twice the average duration of all tasks. 

WITH AvgDuration AS (
  SELECT AVG(DATEDIFF(End_Date, Start_Date)) AS Avg_Task_Len 
  FROM Projects
)

SELECT Task_ID, DATEDIFF(End_Date, Start_Date) AS Task_Duration
FROM Projects, AvgDuration
WHERE DATEDIFF(End_Date, Start_Date) > AvgDuration.Avg_Task_Len * 2
ORDER BY Task_Duration DESC
; 

+---------------+---------+
| Column Name   | Type    |
+---------------+---------+
| article_id    | int     |
| author_id     | int     |
| viewer_id     | int     |
| view_date     | date    |
+---------------+---------+
--There is no primary key (column with unique values) for this table, the table may have duplicate rows.
--Each row of this table indicates that some viewer viewed an article (written by some author) on some date. 
--Note that equal author_id and viewer_id indicate the same person.
 

--Write a solution to find all the authors that viewed at least one of their own articles.

--Return the result table sorted by id in ascending order. 

SELECT DISTINCT author_id AS id
FROM Views
WHERE author_id IN (
    SELECT viewer_id
    FROM Views
    WHERE author_id = viewer_id
)
ORDER BY id ASC
; 

--Table: Visits

+-------------+---------+
| Column Name | Type    |
+-------------+---------+
| visit_id    | int     |
| customer_id | int     |
+-------------+---------+
--visit_id is the column with unique values for this table.
--This table contains information about the customers who visited the mall.
 
--Table: Transactions

+----------------+---------+
| Column Name    | Type    |
+----------------+---------+
| transaction_id | int     |
| visit_id       | int     |
| amount         | int     |
+----------------+---------+
--transaction_id is column with unique values for this table.
--This table contains information about the transactions made during the visit_id.

--Write a solution to find the IDs of the users who visited without making any transactions and the number of times they made these types of visits.
--Return the result table sorted in any order.

SELECT v.customer_id, COUNT(v.visit_id) AS count_no_trans
FROM Visits v
LEFT JOIN Transactions t ON v.visit_id = t.visit_id
WHERE t.transaction_id IS NULL
GROUP BY v.customer_id
; 

--Table: Weather

+---------------+---------+
| Column Name   | Type    |
+---------------+---------+
| id            | int     |
| recordDate    | date    |
| temperature   | int     |
+---------------+---------+
--id is the column with unique values for this table.
--There are no different rows with the same recordDate.
--This table contains information about the temperature on a certain day.
 
--Write a solution to find all dates' id with higher temperatures compared to its previous dates (yesterday).
--Return the result table in any order.  

SELECT A.id 
FROM Weather A 
INNER JOIN Weather B 
ON B.recordDate = (A.recordDate - INTERVAL 1 Day)  
WHERE A.temperature > B.temperature
; 
